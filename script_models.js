var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );

var camera_target = new THREE.Vector3(0,0,0);
var camera_azimuth = 95;
var camera_elevation = 2;
var camera_radius = 10;


function setCameraPosition(target, azimuth, elevation, radius){
  
  camera.position.x = target.x + radius * Math.sin(elevation) * Math.cos(azimuth);
  camera.position.y = target.y + radius * Math.cos(elevation);
  camera.position.z = target.z + radius * Math.sin(elevation) * Math.sin(azimuth);
  
  camera.lookAt(target);
}

setCameraPosition(camera_target, camera_azimuth, camera_elevation, camera_radius);

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

renderer.domElement.addEventListener("wheel", function(wheelEvent){
  camera_radius = (camera_radius + camera_radius * (wheelEvent.deltaY/1000));

  if(camera_radius < 1){
    camera_radius = 1;
  }

  setCameraPosition(camera_target, camera_azimuth, camera_elevation, camera_radius);
  return false;
});


let mouse_is_down = false;
let camera_start;
let mouse_start;
let downListener = (e) => {
  mouse_is_down = true;
  mouse_start = {x: e.clientX, y: e.clientY};
  camera_start = {a: camera_azimuth, e: camera_elevation};
}
renderer.domElement.addEventListener('mousedown', downListener)
let moveListener = (e) => {
    if(mouse_is_down){
      camera_azimuth = (camera_start.a - (mouse_start.x - e.clientX)/100)%360;
      camera_elevation = camera_start.e + (mouse_start.y - e.clientY)/100;
      if(camera_elevation > 3.14159){
        camera_elevation = 3.14159;
      }else if(camera_elevation < 0.001){
        camera_elevation = 0.001;
      }
      setCameraPosition(camera_target, camera_azimuth, camera_elevation, camera_radius);
    }
}
renderer.domElement.addEventListener('mousemove', moveListener)
let upListener = (e) => {
  if(mouse_start.x == e.clientX && mouse_start.y == e.clientY){
    // this is a click
    
  }
  mouse_is_down = false;
}
renderer.domElement.addEventListener('mouseup', upListener)


var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
light.position = new THREE.Vector3(10,1,5);
scene.add( light );

var ambient = new THREE.AmbientLight( 0xffffff, 0.5 );
scene.add( ambient );


// ------- END OF CAMERA MOVING CODE

// ------- PUT SOME STUFF IN ThE WORLD

var spheres= [{p:new THREE.Vector3(0,13,0), r:1},
              {p:new THREE.Vector3(6,9,0), r:2},
              {p:new THREE.Vector3(-30,6,12), r:5},
              {p:new THREE.Vector3(2,-7,21), r:6},
              {p:new THREE.Vector3(-50,3,32), r:5},
              {p:new THREE.Vector3(40,-11,-4), r:3.3},];

var volume_sphere_radius = 0.7;

var colors = [0xf00ff0, 0xffff00, 0x0f00ff, 0xff0f4f];
var currentColor = 0;

for(var i in spheres){
  let geometry = new THREE.SphereGeometry(spheres[i].r, 12, 8);
  let material = new THREE.MeshLambertMaterial( { color: colors[currentColor] } );
  currentColor = (currentColor + 1)%4;
  let sph = new THREE.Mesh( geometry, material );
  sph.position.x = spheres[i].p.x;
  sph.position.y = spheres[i].p.y;
  sph.position.z = spheres[i].p.z;
  scene.add( sph );
}


function starSprite()
{
    let img = new Image();
    img.src = "/black_star.png";
    var texture = new THREE.Texture(img); 
    texture.needsUpdate = true;
    var spriteMaterial = new THREE.SpriteMaterial( 
        { map: texture} );
    var sprite = new THREE.Sprite( spriteMaterial );
    sprite.scale.set(100,100,1.0);
    sprite.center = new THREE.Vector2(0.5,0.5);

    return sprite;
}

//let sprite = starSprite();
//sprite.position.set(new THREE.Vector3(10,10,10));
//scene.add(sprite);

var spriteMap = new THREE.TextureLoader().load( "/black_star.png" );
var spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap } );
var sprite = new THREE.Sprite( spriteMaterial );
console.log(sprite);
scene.add( sprite );

// -------


// BUILD A TERRAIN
// var map is defined in map.js (generated by server)
// it is a 2d array of heights

var terrain = new THREE.Geometry();

for(var i = 0; i < map.length; i++){
  for(var j = 0; j < map[i].length; j++){
    terrain.vertices.push(new THREE.Vector3(i,map[i][j]/30,j));
  }
}

for(var x = 0; x < map.length-1; x++){
  let w = map[x].length;
  for(var y = 0; y < w-1; y++){
    let f = new THREE.Face3(x*w+y, x*w+y+1, (x+1)*w+y+1);
    let h = [terrain.vertices[x*w+y].y, terrain.vertices[x*w+y+1].y, terrain.vertices[(x+1)*w+y+1].y];
    let d = 20
    f.vertexColors[0] = new THREE.Color(h[0]/d,0.5,0.5);
    f.vertexColors[1] = new THREE.Color(h[1]/d,0.5,0.5);
    f.vertexColors[2] = new THREE.Color(h[2]/d,0.5,0.5);
    terrain.faces.push(f);
    f = new THREE.Face3(x*w+y, (x+1)*w+y+1, (x+1)*w+y);
    h[1] = h[2];
    h[2] = terrain.vertices[(x+1)*w+y].y;
    f.vertexColors[0] = new THREE.Color(h[0]/d,0.5,0.5);
    f.vertexColors[1] = new THREE.Color(h[1]/d,0.5,0.5);
    f.vertexColors[2] = new THREE.Color(h[2]/d,0.5,0.5);
    terrain.faces.push(f);
  }
}

terrain.computeFaceNormals();
terrain.computeVertexNormals();

let mat = new THREE.MeshPhongMaterial({ vertexColors: THREE.VertexColors });
var m = new THREE.Mesh(terrain, mat);
m.material.side = THREE.DoubleSide;
scene.add(m);


function animate() {
  requestAnimationFrame( animate );
  renderer.render( scene, camera );


  
}
animate();
